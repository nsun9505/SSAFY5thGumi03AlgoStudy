# [해시] 위장

## 분류
> 자료구조
>
> 해시

## 코드
```java
import java.util.HashMap;

public class Solution {
    public int solution(String[][] clothes) {
        int answer = 0;
        HashMap<String, Integer> clothMap = new HashMap<>();
        for(int i=0; i<clothes.length; i++){
            if(clothMap.containsKey(clothes[i][1]))
                clothMap.put(clothes[i][1], clothMap.get(clothes[i][1]) + 1);
            else
                clothMap.put(clothes[i][1], 1);
        }

        if(clothMap.size() == 1)
            return clothMap.get(clothes[0][1]);

        int[][] arr = new int[clothMap.size()][clothMap.size()];
        int idx=0;
        int sum = 0;
        for (String key : clothMap.keySet()) {
            arr[0][idx] = clothMap.get(key);
            sum += arr[0][idx++];
        }

        for(int i=1; i<arr.length; i++){
            for(int j=0; j<arr.length; j++){
                for(int k=j+1; k<arr.length; k++){
                    arr[i][j] += arr[0][j] * arr[i-1][k];
                }
                sum += arr[i][j];
            }
        }
        return sum;
    }
}
```

## 문제풀이
의상 종류에 따라 카운트하기 위해 Map을 사용했습니다.
   - key 값을 의상 종류로 주고 카운트를 하면 됩니다.

문제는 지금부터..

조합의 수를 구하라고 했지만, 하나의 옷을 입는 경우, 두개의 옷을 입는 경우, ..., N개의 옷을 입는 경우를 모두 합해야 합니다!

그러면 이건 부분집합 문제가 됩니다.

부분집합으로 N이 최대 30이 될 수 있는데, N이 30일 때 부분집합을 구한다면 2^30 - 1(-1은 하나도 안 입는 경우는 빼는 것입니다. 집합에는 공집합도 포함이니깐!)
   - 2^10 * 2^10 * 2^10 = 1024 * 1024 * 1024 = 1,073,741,824가 나옵니다.
   - 음 10억이 넘어가니깐 문제에 주어진 시간은 없지만, 1초에 1억번의 연산이 가능하다고 하다면 10초가 걸리게 됩니다.
   - 그래서 아마 부분집합으로 풀면 테스트 케이스 1번에서 시간초과가 뜨지 않았나 싶습니다.

그러면 조금 확장해서 생각해봅니다.

1개의 옷을 입을 경우, 2개의 옷을 입을 경우를 모두 구해보는 겁니다.
   - DP를 사용해서~

DP의 기본은 메모이제이션! 계산했던 값을 다시 쓰므로 빠르게(?) 답을 구할 수 있습니다.

예를 들어, 모자의 개수가 2개, 상의 개수가 1개, 바지 개수가 1개라고 합시다!
   - 모자의 인덱스는 0
   - 상의의 인덱스는 1
   - 바지의 인덱스는 2
   - 의류 종류의 총 개수는 3입니다.

배열을 정의합니다 : arr[i][j] 
   - arr[i][j] : (i+1)개의 옷을 입을 때 옷 종류 j(0 이면 모자, 1이면 상의, 2면 바지)와 조합해서 입을 수 있는 옷의 수를 의미합니다.

그러면 이 문제에는 어떻게 적용이 되냐면, 처음 arr[0][j](j = 0 ~ N-1)에는 의류 종류 한 가지만 입는 경우이므로 j번째 의류 종류의 수로 세팅합니다.

이제 두 개의 옷을 입는 경우를 생각해보겠습니다.

먼저 모자에 대해서 구해보면, 모자 + 상의, 모자 + 바지가 됩니다.
   - 이걸 계산하면, (2 * 1) + (2 * 1) = 4가 됩니다.
   - 이 값을 이제 arr[1][0]에 넣어줍니다.
   - 왜냐하면, 위에서 말했다시피 i+1 = 1+1 = 2개의 옷을 입을 때 조합을 구하는 것입니다.
   - 자기 자신을 빼고 자신의 뒤에 있는 애들이랑 모자의 개수랑 곱해서 더해주면 되는 것입니다.

다음으로 상의에 대해서 구해보면, 상의 + 하의 경우밖에 없습니다.
   - 상의 + 모자는 이미 모자와의 조합을 구하면서 구했으므로 더 이상 구할 필요가 없습니다!
   - 문제도 조합을 구하고 했으니 말이죠.
   - 그러면 arr[1][1]에 상의 + 하의 조합에 대해서 넣어줍니다. 
   - 상의도 1개, 하의도 1개이므로 arr[1][1]에는 1이 들어갑니다.

다음으로 하의에 대해서 구해보면, 구할게 없습니다!
   - 하의 + ? 해야 하는데 더 이상 옷의 종류가 없는 것이죠!

그러면 2개를 입는 조합에 대해서는 모두 구했습니다.

이제 3개를 입는 조합에 대해서 구해보면, 모자 + 상의 + 하의 밖에 없죠!
   - 그런데 여기서 모자를 빼봅시다! 그러면 상의 + 하의 조합이죠!
   - 상의 + 하의 조합은 이미 구했습니다! => arr[1][1] : j(=1)번째 입을 포함하여 i+1 = 1+1 = 2개를 입을 때를 의미
   - 그러면 이미 구한 값인 arr[1][1]에 모자의 수를 곱해서 arr[2][0]에 저장하면 되겠죠!

그러면 DP 식은 아래와 같습니다.

DP[0][j] = 의상 종류의 개수(j = 0 ~ N-1) : 모자가 몇개인지, 바지가 몇개인지를 의미합니다.

DP[i][j] += DP[0][j] * DP[i-1][k]
   - i = 1 ~ N-1
   - j = 0 ~ N-1
   - k = j+1 ~ N-1

i는 i+1개의 옷을 입는 경우를 의미합니다.

j는 의상 종류를 의미합니다.

k는 j와 조합할 수 있는 의류를 의미합니다.

DP[i][j] : j번째 의상 종류을 포함하여 i+1개의 옷을 입을 때의 조합 수
DP[0][j] : j번째 의상 하나만 입었을 때
DP[0][j] * DP[i-1][k] : i-1번째 의상을 입은 경우에 현재 의상 종류의 개수를 곱해서 i개의 의상을 입을 때 수를 알 수 있습니다.
   - 여기가 모자 + 상의 + 하의를 입는 조합에서 이미 상의 + 하의(DP[i-1][k])는 구했으므로 여기에 모자를 입는 경우(DP[0][j])만 곱해준다면
   - 모자 + 상의 + 하의 조합의 수를 알 수 있습니다.